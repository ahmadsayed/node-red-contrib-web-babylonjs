<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Homera Node-red 3D</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
</head>

<body>
    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP
    <script type="text/javascript">
        var scene;
        function connectToWs() {

            var ws;
            console.log("============== Establish Connection ============")
            if ("WebSocket" in window) {
                // Let us open a web socket
                //TODO: Remove localhost
                ws = new WebSocket("ws://localhost:9099");
                ws.onopen = function () {
                    // Web Socket is connected, send data using send()
                    ws.send("Message to send");
                    console.log("Message to Send");
                };

                ws.onmessage = function (evt) {
                    var received_msg = JSON.parse(evt.data);
                    switch (received_msg.type) {
                        case 'position':
                            let mesh = scene.getMeshByName(received_msg.name);
                            if (received_msg.relative) {
                                mesh.position.x += received_msg.values.x;
                                mesh.position.y += received_msg.values.y;
                                mesh.position.z += received_msg.values.z;

                            } else {
                                mesh.position.x = received_msg.values.x;
                                mesh.position.y = received_msg.values.y;
                                mesh.position.z = received_msg.values.z;

                            }
                            break;
                        case 'rotate':
                            console.log("Not yet implemented");
                            break;
                        case 'scale':
                            console.log("Not yet implemented");
                            break;
                        case 'reload':
                            console.log("Reload Recieved");
                            loadScene();
                            break;
                    }
                    console.log("Message is received...");
                };

                ws.onclose = function () {
                    // websocket is closed.                    
                    console.log("Connection is closed...");
                };
                window.onbeforeunload = function (event) {
                    socket.close();
                };
            }

            else {
                // The browser doesn't support WebSocket
                alert("WebSocket NOT supported by your Browser!");
            }
            return ws;
        }

        var canvas = document.getElementById("renderCanvas"); // Get the canvas element 
        var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        /******* Add the create scene function ******/
        var createScene = function () {
            // Create the scene space
            scene = new BABYLON.Scene(engine);
            // Add a camera to the scene and attach it to the canvas
            var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            // Add lights to the scene
            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
            var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), scene);

            return scene;
        };

        var all_meshes = [];

        var drawMeshes = function (scene, sceneData) {
            // Delete all Meshes to support redraw
            all_meshes.forEach(mesh => {
                mesh.dispose();
            });

            // Add and manipulate meshes in the scene
            sceneData.forEach(element => {
                let mesh = null;
                switch (element.type) {
                    case 'sphere':
                        mesh = BABYLON.MeshBuilder.CreateSphere(element.name, element.param, scene);
                        break;
                    case 'box':
                        mesh = BABYLON.MeshBuilder.CreateBox(element.name, element.param, scene);
                        break;
                    case 'plane':
                        mesh = BABYLON.MeshBuilder.CreatePlane(element.name, element.param, scene);
                        break;
                    case 'ground':
                        mesh = BABYLON.MeshBuilder.CreateGround(element.name, element.param, scene);
                        break;
                }
                all_meshes.push(mesh);
            });
        };
        /********** Connect/Reconnect with Heartbeat ****/
        var ws = connectToWs();
        setInterval(() => {
            if (ws.readyState === WebSocket.CLOSED) {
                ws = connectToWs();
            }
        }, 2000);

        var loadScene = function () {
            fetch('/sceneServe').then(res => res.json()).then(res => {
                drawMeshes(scene, res);
                engine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene
                    scene.render();
                });

            });
        }


        /******* Load scene from backend *********/
        var scene = createScene();
        loadScene();

        window.addEventListener("resize", function () { // Watch for browser/canvas resize events
            engine.resize();
        });
    </script>
</body>

</html>